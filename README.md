# Файлы для итогового задания
В директории `tests` находятся тесты для проверки API, которое должно быть реализовано в веб-сервере.
Директория `web` содержит файлы фронтенда.
---------------------------------------------------------------------
Приступаем к итоговому заданию
В итоговом задании вам нужно написать на Go веб-сервер, который реализует функциональность простейшего планировщика задач. Это будет аналог TODO-листа. Это задание на проверку и закрепление навыков по написанию веб-сервера, работе с REST API и базами данных. 
На выполнение итогового задания отводится два спринта. Чтобы упорядочить работу, мы разбили его на шаги. На каждый шаг отведён один урок, где есть постановка текущей задачи с объяснениями, комментариями и подсказками. Если что-то из материалов задания будет непонятно, попробуйте поискать ответ в интернете или обратитесь за помощью к наставникам. Сторонними библиотеками пользоваться можно, но помните: изучение нового пакета займёт время. Возможно, проще будет использовать стандартную библиотеку.  

Что должен делать планировщик
Планировщик хранит задачи, каждая из них содержит дату дедлайна и заголовок с комментарием. Задачи могут повторяться по заданному правилу: например, ежегодно, через какое-то количество дней, в определённые дни месяца или недели. Если отметить такую задачу как выполненную, она переносится на следующую дату в соответствии с правилом. Обычные задачи при выполнении будут просто удаляться. 
API содержит следующие операции:
добавить задачу;
получить список задач;
удалить задачу;
получить параметры задачи;
изменить параметры задачи;
отметить задачу как выполненную.
Проверка сервера и тесты

Работу сервера вы сможете контролировать в браузере. У вас будет готовый фронтенд: html, css, js-файлы, и вы сможете сразу проверить работу приложения в браузере. Фронтенд отправляет на сервер API-запросы, вам нужно будет реализовать их обработку по техническому заданию. Если обработчики будут написаны правильно, фронтенд должен работать без ошибок. 
Кроме этого, у вас будет доступ к тестам для проверки кода. Прохождение тестов — это минимальное условие для передачи кода на проверку.

Задачи со звёздочкой
В уроках вам встретятся задачи со звёздочкой. Выполнять их не обязательно, поэтому ориентируйтесь на свои силы. Дополнительные задачи не сильно сложные, но времени они всё же потребуют. Можете сначала написать сервер в минимальной конфигурации, а затем, если останется время, вернуться к задачам со звёздочкой.

Склонируйте или скачайте репозиторий go_final_project. В нём есть директория tests с тестами для проверки сервера и директория web с файлами фронтенда. Возьмите файлы этого репозитория за основу, в главной директории создайте модуль Go и файл main.go. Дальше на каждом шаге добавляйте сюда нужные обработчики и функции. Можно сразу продумать, как будет организован ваш код: можно разбивать его на пакеты или только на файлы рядом с main.go. В любом случае, не пихайте всё в один файл. Ревьюер вернёт проект на доработку, если не поймёт, что и где у вас находится. 
Тесты запускаются из основной директории. Перед запуском тестов проверьте, что ваш веб-сервер работает.

Шаг 1. Запускаем веб-сервер
Сначала нужно создать минимальный веб-сервер, который будет слушать определённый порт и возвращать запрашиваемые файлы фронтенда. По умолчанию сервер должен слушать порт 7540. Если вы хотите использовать другой порт, укажите его в переменной Port в файле tests/settings.go. Или же нужно определить переменную окружения TODO_PORT с  соответствующим значением.
Сервер при запросе http://localhost:7540/ должен возвращать index.html из поддиректории web. Главная страница запрашивает .js и .css файлы, поэтому веб-сервер также должен их возвращать. Например:
http://localhost:7540/js/scripts.min.js возвращает ./web/js/scripts.min.js;
http://localhost:7540/css/style.css возвращает ./web/css/style.css;
http://localhost:7540/favicon.ico возвращает ./web/favicon.ico.
По сути, на этом шаге нужно реализовать простейший файл-сервер. Сделать это не сложнее, чем создать обработчик событий. Этот пример будет возвращать файлы из поддиректории, имя которой хранится в переменной webDir:

http.Handle("/", http.FileServer(http.Dir(webDir))) 
Там может быть указан как абсолютный, так и относительный путь.
Для проверки запустите go test -run ^TestApp$ ./tests. Если тест завершился успешно, можете открыть в браузере http://localhost:7540/.

Задание со звёздочкой
Реализуйте возможность определять извне порт при запуске сервера. Если существует переменная окружения TODO_PORT, сервер при старте должен слушать порт со значением этой переменной. 
Получить значение переменной окружения поможет функция os.Getenv(key string) string.

Шаг 2. Проектируем и создаём БД
Вам же охота сохранять созданные в TODO-листе задачи? Тогда нужно спроектировать и создать базу данных для хранения задач. Для этого будет использоваться база данных SQLite. Других сущностей, кроме задач, не планируется, поэтому будет достаточно одной таблицы. Помимо веб-сервера базу данных могут использовать другие утилиты, поэтому принято решение дать имена таблице и её полям. Файл базы данных scheduler.db должен содержать таблицу scheduler с такими колонками:

id — автоинкрементный идентификатор;
date — дата задачи, которая будет хранится в формате YYYYMMDD или в Go-представлении 20060102;
title — заголовок задачи;
comment — комментарий к задаче;
repeat — строковое поле не более 128 символов, которое будет содержать правила повторений для задачи. Формат правил будет описан в следующем шаге.

Выберите подходящие типы для полей самостоятельно. Задачи должны будут возвращаться отсортированными по дате, поэтому не забудьте создать индекс по полю date. 
Сделайте так, чтобы при запуске сервер проверял, существует ли в директории приложения файл scheduler.db. Если его нет, следует создать базу данных с таблицей scheduler. Вот пример кода, который определяет директорию приложения и проверяет, есть ли в ней нужный файл:

appPath, err := os.Executable()
if err != nil {
    log.Fatal(err)
}
dbFile := filepath.Join(filepath.Dir(appPath), "scheduler.db")
_, err = os.Stat(dbFile)

var install bool
if err != nil {
    install = true
}
// если install равен true, после открытия БД требуется выполнить 
// sql-запрос с CREATE TABLE и CREATE INDEX 

Для проверки запустите go test -run ^TestDB$ ./tests. По умолчанию тест считает, что файл с базой данных scheduler.db находится в родительской директории. Вы можете указать другой путь в значении переменной DBFile в файле ./tests/settings.go. Или можно определить переменную окружения TODO_DBFILE и хранить путь к базе данных там.
Если тест выполнился успешно, можно переходить к следующему шагу.

ШАГ 3. ПРАВИЛА ВЫПОЛНЕНИЯ ЗАДАЧ

Загрузка фронтенда есть, создание SQlite БД имеется. Но прежде чем реализовывать обработчики API-запросов, необходимо написать функцию, которая будет вычислять следующую дату для задачи в соответствии с указанным правилом. Пожалуй, это самая сложная часть итогового задания. Поэтому мы разбили правила на две группы: базовые и со звёздочкой. Работу базовых правил реализовать обязательно — это минимум. Но будет отлично, если вы напишите поддержку для всех правил.
Правила повторения задач хранятся в колонке repeat. Ниже перечислены базовые правила.
1. Если правило не указано, отмеченная выполненной задача будет удаляться из таблицы;
2. d <число> — задача переносится на указанное число дней. Максимально допустимое число равно 400. Примеры:
d 1 — каждый день;
d 7 — для вычисления следующей даты добавляем семь дней;
d 60 — переносим на 60 дней.
3. y — задача выполняется ежегодно. Этот параметр не требует дополнительных уточнений. При выполнении задачи дата перенесётся на год вперёд.
   
Правила со звёздочкой идут ниже, их реализация будет немного посложнее.
w <через запятую от 1 до 7> — задача назначается в указанные дни недели, где 1 — понедельник, 7 — воскресенье. Например:
w 7 — задача перенесётся на ближайшее воскресенье;
w 1,4,5 — задача перенесётся на ближайший понедельник, четверг или пятницу;
w 2,3 — задача перенесётся на ближайший вторник или среду.
m <через запятую от 1 до 31,-1,-2> [через запятую от 1 до 12] — задача назначается в указанные дни месяца. При этом вторая последовательность чисел опциональна и указывает на определённые месяцы. Например:
m 4 — задача назначается на четвёртое число каждого месяца;
m 1,15,25 — задача назначается на 1-е, 15-е и 25-е число каждого месяца;
m -1 — задача назначается на последний день месяца;
m -2 — задача назначается на предпоследний день месяца;
m 3 1,3,6 — задача назначается на 3-е число января, марта и июня;
m 1,-1 2,8 — задача назначается на 1-е и последнее число февраля и авгуcта.

Рекомендуем реализовать примерно такую функцию:
func NextDate(now time.Time, date string, repeat string) (string, error) 

с параметрами:
now — время от которого ищется ближайшая дата;
date — исходное время в формате 20060102, от которого начинается отсчёт повторений;
repeat — правило повторения в описанном выше формате.

Функция возвращает следующую дату в формате 20060102 и ошибку. Возвращаемая дата должна быть больше даты, указанной в переменной now.
Для закрепления посмотрите на примеры. Если предположить, что сегодня 26.01.2024, тогда:
NextDate(now, "20240229", "y") возвращает 20250301;
NextDate(now, "20240113", "d 7") возвращает 20240127;
NextDate(now, "20240116", "m 16,5") возвращает 20240205;
NextDate(now, "20240201", "m -1,18") возвращает 20240218;

Функция должна возвращать ошибки при некорректных датах или если формат правила повторения не соблюден. Например, ошибка должна возвращаться в следующих случаях:
в колонке repeat — пустая строка;
время в переменной date не может быть преобразовано в корректную дату — ошибка выполнения time.Parse("20060102", d);
указан неверный формат repeat.
Вот примеры неправильных форматов:
l 34 — недопустимый символ;
d — не указан интервал в днях;
d 405 — превышен максимально допустимый интервал;
w 8 — недопустимое значение 8;
m 4,40 — недопустимый день месяца;
m 5 1,13 — недопустимый месяц.
Если вы реализуете только базовые правила d и y и не выполняете распознавание форматов w ... и m ..., тогда при получении таких строк просто возвращайте ошибку — например, неподдерживаемый формат.
На следующем шаге уже начнётся реализация API-обработчиков. Для подготовки следует немного размяться. Добавьте к серверу GET-обработчик api/nextdate, который должен принимать запросы в таком формате: "/api/nextdate?now=<20060102>&date=<20060102>&repeat=<правило>". Например: "api/nextdate?now=20240126&date=20240126&repeat=y". При этом в обработчике нужно будет вызвать созданную вами функцию и вернуть дату следующего выполнения в формате 20060102 или текст ошибки.
Когда вы напишете функцию и обработчик /api/nextdate, для проверки запустите go test -run ^TestNextDate$ ./tests. Если вы реализовали поддержку всех вариантов правил повторения, предварительно присвойте true значению переменной FullNextDate в файле tests/settings.go. Тогда тест проверит правила для недель и месяцев.

Советы по решению
Чтобы реализовать требуемый функционал, не нужно придумывать хитрые алгоритмы. Есть полезная функция time.AddDate(), которая добавляет ко времени указанное количество лет, месяцев и дней. Например, для правила d <дни> достаточно в цикле вызывать AddDate( 0, 0, <дни>) до тех пор, пока дата не станет больше времени now.

Если речь идёт о днях недели или месяца, определите мапу допустимых значений и затем день за днём проверяйте получаемые даты с помощью AddDate(0, 0, 1). Это только один вариант реализации. Вполне возможно, что вы сможете придумать свой простой и эффективный алгоритм.
Для получения GET-параметров (now, date, repeat) в обработчике можно использовать метод (r *Request) FormValue(key string) string из пакета net/http.
